<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sorting</title>
</head>
<body>
  <h1>Sorting is one of the biggest problems big companies need to solve along with searching</h1>
  <p>Which is the problem with the .sort() method build in programming languages </p>
  <ol>
    <li>in js the elements are first being transformed in strings and then sorted by unicode characters - check the unicode table   (2 = 50)
      <p>to make sure the sort method works the way you expect it to add the function description to it ->function(a, b){a-b/ b-a/ a.localeSort(b)</p>
    </li>
    <li>in js the implementation of the methods is also dependent on the js engines used by different browsers - so the chrome one can differ from the firefox one</li>
    <li>there are many sorting algorithms and each of them are efficient for solving different sorting problems - check <a href="https://www.toptal.com/developers/sorting-algorithms">check sorting alg in action</a></li>
  </ol>
  <h1><a href="https://www.youtube.com/channel/UCIqiLefbVHsOAXDAxQJH7Xw">Sorting dances</a></h1>
  <h2>Bubble sort</h2>
  <p>is the simplest and one of the less efficient ones - time complexity O(n^2)-average and space complexity O(1) - we are not creating any new data structures - </p>
  <h2>Selection sort</h2>
  <p>Time complexity - O(n^2) - space complexity O(1)</p>
  <h2>Insertion sort very useful when we know that the list is almost sorted or the amount of data to sort is small</h2>
  <p>The time complexity in the best scenario can be O(n)/ worst scenario O(n^2) - space complexity O(1)</p>
  <h2>Divide and Conquer(recursion) O(n log n)- Merge sort and Quick sort</h2>
  <p>Time complexity O(n log n)</p>
  <h2>Merge sort</h2>
  <p>One of the most efficient way to sort</p>
  <p>Time complexity O(n log n)</p>
  <ul>
    <li>n - because we need to check each item in the array</li>
    <li>log n - is like the height of the tree - ?</li>
  </ul>
  <p>Space complexity - O(n) - we add the elements to a new array while sorting them</p>
  <h2>Quick sort</h2>
  <p>Is the most popular sorting alg because the Time complexity in the best case is O(log n) - learn to calculate log n ?</p>
  <p>WORST CASE SCENARIO - IF THE CHOSEN PIVOT IS THE SMALLEST/ BIGGEST ITEM - TIME COMPLEXITY - O(n^2)</p>

  <p><a href="https://stackoverflow.com/questions/2467751/quicksort-vs-heapsort">Quicksort vs heapsort</a></p>
  <h2>Which sort is best </h2>
  <p>Insertion sort - is the best choice when the input is small and almost sorted</p>
  <p>Bubble sort & selection sort - never used - Time complexity O(n^2)</p>
  <p>Merge sort - good time complexity - O(n log n) - bad space complexity O(n)</p>
  <p>Quicksort - the most popular - best case Time complexity O(n log n)/ worst O(n^2) - space complexity - best case - O(log n)/ worst case O(n) - is not a stable algorithm( the equal input can be in different places in the output)</p>

  <h2>Non comparison sort - only works for numbers and small inputs</h2>
  <p>Counting sort</p>
  <p>Redix sort </p>
</body>
</html>